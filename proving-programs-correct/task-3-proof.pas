{N >= 0}
	i, x := 0, 0;
{inv P: 0 <= i <= N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))}
{bound t: N - i}

	do i < N --> if even(i) & odd(a[i])  --> x, i := x + 1, i + 1
				   |!((even) & odd(a[i)) --> i := i + 1
				 fi
	od
	
{R: x = (N_j: 0 <= j < i: even(i) & odd(a[j]))}

1) Q ==> WP(I, P)

	N >= 0 ==> (i, x := 0, 0, 0 <= i <= N & x = (N_j: 0 <= j < i: even(i) & odd(a[j])))
	N >= 0 ==> 0 <= 0 & 0 <= N & 0 = (N_j: 0 <= j < 0: even(i) & odd(a[j]))
	N >= 0 ==> N >= 0 & 0 = 0
	N >= 0 ==> N >= 0
	TRUE // alpha ==> alpha

2) P & B ==> WP(S, P)

	P & i < N ==> WP(IF, P) // Возьмём консеквент импликации
	WP(IF, P) ==> domain(B1 v B2) & (B1 v B2) & (B1 ==> WP(S1, P)) & (B2 ==> WP(S2, P)) // domain(BB) ==> TRUE
	((even(i) & odd(a[i])) v (!((even) & odd(a[i)))) & (B1 ==> WP(S1, P)) & (B2 ==> WP(S2, P))
	//((even(i) & odd(a[i])) v (!((even) & odd(a[i)))) ==> TRUE по закону исключения третьего
	(even(i) & odd(a[i])) ==> WP(x, i := x + 1, i + 1,
		0 <= i <= N & x = (N_j: 0 <= j < i: even(i) & odd(a[j])))
	& (!((even) & odd(a[i))) ==> WP(i := i + 1,
		0 <= i <= N & x = (N_j: 0 <= j < i: even(i) & odd(a[j])))
	// выполняем команду подстановки в предикат P:
	(even(i) & odd(a[i])) ==> -1 <= i < N & (x + 1) = (N_j: 0 <= j <= i: even(i) & odd(a[j]))
	& (!((even) & odd(a[i))) ==> -1 <= i < N & x = (N_j: 0 <= j <= i: even(i) & odd(a[j]))
	// из первого квантора количества выносим 1 элемент и изменяем область j на 0 <= j < i
	// из второго квантора количества выносим 0 элемент и изменяем область j на 0 <= j < i, так как
	// элемент посылки не является even(i) & odd(a[i]), тем который нам нужен
	(even(i) & odd(a[i])) ==> -1 <= i < N & (x + 1) = (N_j: 0 <= j < i: even(i) & odd(a[j])) + 1
	& (!((even) & odd(a[i))) ==> -1 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j])) + 0
	// сокращаем единицы в уравнении с первым квантором и получить, что правые части импликаций равны
	(even(i) & odd(a[i])) ==> -1 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
	& (!((even) & odd(a[i))) ==> -1 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
	// обозначим левую часть через alpha, а правую через beta и докажем
	(a ==> b) & (!a ==> b)
	/*-----------------------------------------------------
	*	(a ==> b) & (!a ==> b)	
	*	(!a v b) & (a v b)
	*	(!a & a) v b
	*	// (!a & a) = FALSE по закону противоречия
	*	FALSE v b
	*	b // по закону упрощения дизьюнкции
	*-----------------------------------------------------*/
	// по (a ==> b) & (!a ==> b) ==> b останется только правая часть импликации:
	WP(IF, P) ==> -1 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
	// вернёмся к исходному выражению P & i < N ==> WP(IF, P)
	0 <= i <= N & x = (N_j: 0 <= j < i: even(i) & odd(a[j])) & i < N
		==> -1 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
	// объединим 0 <= i <= N и i < N, получим:
	0 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
		==> -1 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
	// правую часть распишем по закону дистрибутивности, добавляя еще один дизьюнкт:
	0 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
		==> -1 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
	0 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
		==> 0 <= i < N & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
			v (i = -1 & x = (N_j: 0 <= j < i: even(i) & odd(a[j]))
	// получим, что один из дизьюнктов консеквента однозначно равен антецеденту выражения
	// и поэтому по НЛЛ 2 a => a v b мы получаем:
	TRUE

3) P & !BB ==> R 